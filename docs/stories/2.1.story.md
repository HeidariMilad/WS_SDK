# Story 2.1 – Navigation & Refresh Commands

## Status

Approved

## Story

**As a** technical evaluator using the demo,
**I want** navigation and refresh-style commands to visibly and reliably affect the demo UI,
**so that** I can confirm the SDK correctly interprets and applies route changes and element refreshes from remote commands.

## Acceptance Criteria

From PRD Epic 2 – Command Execution Engine:

1. AC1: `navigate` triggers Next.js router navigation and logs the destination route without full reload.
2. AC2: `refresh_element` toggles lightweight state or invokes callbacks to re-render targeted components.
3. AC3: Demo displays confirmation (log or notification) indicating command completion.

## Tasks / Subtasks

- [ ] Task 1 – Implement `navigate` command handler (AC: 1, 3)
  - [ ] Implement a `navigate` handler in `packages/sdk/src/commands` that uses the demo’s routing API (e.g., Next.js router) to change the route without a full page reload.  
        [Source: architecture/overview-and-modules.md#module-boundaries]
  - [ ] Ensure the handler reads the destination path from the command payload in a documented, predictable way (e.g., `payload.value` or `payload.options.path`).  
        [Source: architecture/shared-types-and-api.md#shared-types--api-contract]
  - [ ] Log a `CommandResult` entry including the destination route and success status.  
        [Source: architecture/command-pipeline.md#websocket-command-pipeline]

- [ ] Task 2 – Implement `refresh_element` command handler (AC: 2, 3)
  - [ ] Implement `refresh_element` in `packages/sdk/src/commands` to trigger a lightweight re-render of the targeted component, e.g., toggling a key, calling a callback, or updating local state.  
        [Source: architecture/overview-and-modules.md#module-boundaries]
  - [ ] Ensure that refresh operations are idempotent and do not break component internal state.
  - [ ] Emit a success `CommandResult` including a short description of the refresh action taken.  
        [Source: architecture/command-pipeline.md#websocket-command-pipeline]

- [ ] Task 3 – Integrate with targeting and dispatcher (AC: 1, 2)
  - [ ] Ensure `navigate` commands do not require an element target and are handled at the router level, while `refresh_element` uses the targeting utility to resolve its target.  
        [Source: architecture/command-pipeline.md#websocket-command-pipeline]
  - [ ] Validate that bad payloads or missing fields result in warning-level `CommandResult` entries rather than runtime exceptions.

- [ ] Task 4 – Demo UI feedback for navigation and refresh (AC: 3)
  - [ ] Update the demo’s command timeline to clearly label `navigate` and `refresh_element` commands with distinct icons and concise descriptions.  
        [Source: front-end-spec.md#command-feedback-guidelines]
  - [ ] Optionally surface a transient toast when navigation or refresh completes, in line with the UX spec’s feedback principles.  
        [Source: front-end-spec.md#command-feedback-guidelines]

- [ ] Task 5 – Performance and UX validation (AC: 1, 2, 3)
  - [ ] Confirm `navigate` does not trigger full page reloads and stays within performance targets.  
        [Source: architecture/security-performance-monitoring.md#performance-targets]
  - [ ] Confirm `refresh_element` is sufficiently lightweight and does not cause visible jank.

## Dev Notes

### Previous Story Insights

- Builds on Epic 1: connection, dispatcher, and targeting are already in place.
- This story focuses on introducing the first concrete command handlers and verifying the pipeline.

### Implementation Playbook (Dev Agent)

Follow these steps when implementing this story:

1. **`navigate` command**
   - Implement `packages/sdk/src/commands/navigate.ts` (or similar) to use the demo’s router (e.g., Next.js) for client-side navigation.
   - Read the destination from the command payload in a documented way (e.g., `payload.value` or `payload.options.path`).
   - Ensure no full page reload occurs; this should be SPA-style navigation.
   - Emit `CommandResult` entries with destination route and status.

2. **`refresh_element` command**
   - Implement `refresh_element` to trigger lightweight re-rendering of the targeted component (e.g., state toggle, callback).
   - Keep the operation idempotent and non-destructive to internal component state.
   - Emit success `CommandResult` entries with a short description of the refresh behavior.

3. **Pipeline & targeting integration**
   - Ensure `navigate` works without a DOM target (router-level), while `refresh_element` uses the targeting utility to resolve an element.
   - Handle bad payloads/missing fields via warning-level `CommandResult` instead of throwing.

4. **Demo UI feedback**
   - Update the command timeline to label `navigate` and `refresh_element` with clear icons and descriptions.
   - Optionally add a small toast or inline confirmation when these commands complete.

5. **Performance checks**
   - Confirm that navigation is fast and that `refresh_element` does not cause jank or redundant re-renders.

Dev should update Tasks/Subtasks and Dev Notes to reflect the implemented details; QA Results remain for QA.

### Data Models

- Uses existing `CommandPayload` and `CommandResult` types; no new persistent models are required.  
  [Source: architecture/shared-types-and-api.md#shared-types--api-contract]

### API Specifications

- Command names: `"navigate"` and `"refresh_element"` are part of the shared `CommandName` union.  
  [Source: architecture/shared-types-and-api.md#shared-types--api-contract]
- For navigation, the payload should include a route path; final shape to be documented in comments and dev-facing docs.

### Component Specifications

- Demo’s router integration should respect the UX spec: navigation is quick and does not disrupt other UI elements.
- Timeline entries for these commands should align with the Command Feedback Guidelines for labels, icons, and tooltips.  
  [Source: front-end-spec.md#command-feedback-guidelines]

### File Locations & Structure

- Command handlers:
  - `packages/sdk/src/commands/navigate.ts`
  - `packages/sdk/src/commands/refresh-element.ts` (or similar naming).  
    [Source: architecture/overview-and-modules.md#module-boundaries]
- Demo integration:
  - `apps/demo` components consuming the SDK’s command stream and router.

### Testing Requirements

- Unit tests for handlers:
  - Validate correct router invocation and logging for `navigate`.
  - Validate idempotent, repeatable behavior for `refresh_element`.
- Integration tests in demo:
  - Confirm that navigation and refresh commands show up correctly in the timeline and that the UI reflects their effects.

### Technical Constraints & Considerations

- Ensure handlers are pure and deterministic where possible to simplify testing.
- Avoid mixing navigation side effects with non-related state changes; keep concerns separated.

## Testing

- Manually use mock playlists or developer tools to fire `navigate` and `refresh_element` commands.
- Verify visual behavior, logs, and absence of full page reloads.

## Change Log

| Date       | Version | Description                                   | Author |
| ---------- | ------- | --------------------------------------------- | ------ |
| 2025-11-14 | 0.1.0   | Initial draft of Story 2.1 and task breakdown | SM     |

## Dev Agent Record

_This section is reserved for the Dev Agent to fill in during implementation (agent model, debug log references, completion notes, and file list)._ 

## QA Results

### QA Validation Playbook

When this story is ready for QA review:

1. **Verify Acceptance Criteria directly**
   - AC1: Trigger `navigate` commands and confirm they use router-based navigation without full reload, and that logs show the destination route.
   - AC2: Trigger `refresh_element` on various components and verify they re-render appropriately without breaking state.
   - AC3: Confirm that the demo surfaces clear confirmation (timeline entries and/or notifications) when these commands complete.

2. **Check UX behavior**
   - Ensure navigation does not disrupt other UI elements and follows UX expectations.
   - Confirm timeline entries for these commands are clear and distinguishable.

3. **Record QA result**
   - Summarize findings here with status (READY / NEEDS REVISION / BLOCKED) and any issues.

_This section is reserved for the QA Agent to record validation results and gate decisions for this story._
