# Story 1.2 – WebSocket Client & Retry Logic

## Status

Approved

## Story

**As a** frontend UI command SDK maintainer,
**I want** a resilient WebSocket client with clear connection status and retry behavior,
**so that** remote UI commands can be streamed reliably into the demo without crashing the SDK.

## Acceptance Criteria

From PRD Epic 1 – SDK Foundations & Infrastructure:

1. AC1: WebSocket client connects to configurable endpoint and logs status transitions.
2. AC2: Exponential backoff reconnection attempts trigger after disconnect (maximum delay 3 seconds).
3. AC3: Connection errors surface to demo UI without crashing the SDK.

## Tasks / Subtasks

- [ ] Task 1 – Implement WebSocket connection module (AC: 1)
  - [ ] Create `packages/sdk/src/core/connection` module that encapsulates WebSocket connection lifecycle (connect, disconnect, status events).  
        [Source: architecture/overview-and-modules.md#module-boundaries]
  - [ ] Accept a configurable WebSocket endpoint URL via SDK configuration or environment variables appropriate for demo/mocks.  
        [Source: architecture/platform-deployment.md#deployment-blueprint]
  - [ ] Expose connection status changes (`Connecting`, `Connected`, `Reconnecting`, `Offline`) as an observable or event emitter for the demo UI to subscribe to.  
        [Source: architecture/security-performance-monitoring.md#security-performance--monitoring]

- [ ] Task 2 – Implement exponential backoff reconnection (AC: 2)
  - [ ] Implement reconnection logic using exponential backoff with delays of approximately 1s, 2s, and 3s (cap) after disconnect.  
        [Source: architecture/overview-and-modules.md#overview]
  - [ ] Ensure reconnection attempts stop or slow down appropriately when the browser is offline or when an explicit disconnect is requested.  
        [Source: architecture/platform-deployment.md#resilience--monitoring]
  - [ ] Log each reconnection attempt and outcome via the SDK logging bus for visibility in the demo UI.  
        [Source: architecture/overview-and-modules.md#module-boundaries]

- [ ] Task 3 – Surface connection status and errors to demo UI (AC: 1, 3)
  - [ ] Provide a `ConnectionBanner` or equivalent status component in `apps/demo` that subscribes to the SDK connection status and renders distinct states (Connecting, Connected, Reconnecting, Offline).  
        [Source: architecture/overview-and-modules.md#module-boundaries]
  - [ ] Ensure connection errors produce structured log entries with `status: "error"`, `requestId`, and human-readable `details`, without throwing unhandled exceptions.  
        [Source: architecture/shared-types-and-api.md#shared-types--api-contract]
  - [ ] Add user-visible messaging (e.g., toast or banner) when persistent connection issues occur, with a simple “Retry” affordance.  
        [Source: architecture/platform-deployment.md#resilience--monitoring]

- [ ] Task 4 – Integrate WebSocket client into command pipeline (AC: 1, 3)
  - [ ] Wire the connection module so incoming messages are parsed into `CommandPayload` objects and forwarded to the dispatcher as `message` events.  
        [Source: architecture/command-pipeline.md#websocket-command-pipeline]
  - [ ] Ensure unknown or invalid messages are logged as `UNHANDLED_COMMAND` or equivalent warnings, not fatal errors.  
        [Source: architecture/command-pipeline.md#websocket-command-pipeline]
  - [ ] Verify that loss of connection does not crash the dispatcher or demo UI; command handling simply pauses until reconnection.  
        [Source: architecture/platform-deployment.md#resilience--monitoring]

- [ ] Task 5 – Telemetry and monitoring for connection behavior (AC: 2, 3)
  - [ ] Emit connection lifecycle events into the command timeline/logging UI so evaluators can see when reconnection and errors occur.  
        [Source: architecture/platform-deployment.md#resilience--monitoring]
  - [ ] Ensure connection-related logs respect the SDK logging strategy (severity levels, capped history).  
        [Source: architecture/overview-and-modules.md#module-boundaries]
  - [ ] Confirm that logs integrate with optional Sentry/monitoring adapters without special-case code.  
        [Source: architecture/platform-deployment.md#platform-deployment--resilience]

## Dev Notes

### Previous Story Insights

- Story 1.1 establishes the monorepo, shared tooling, and CI backbone.
- This story builds directly on that structure and should follow existing project scripts and TypeScript configuration.  
  [Source: architecture/project-structure.md#project-structure--workflow]

### Implementation Playbook (Dev Agent)

Follow these steps when implementing this story:

1. **Connection core module**
   - Create `packages/sdk/src/core/connection` for WebSocket lifecycle (connect, disconnect, status events).
   - Accept a configurable WebSocket endpoint via SDK config or environment variables suitable for demo/mocks.
   - Expose status changes (`Connecting`, `Connected`, `Reconnecting`, `Offline`) through an event emitter or observable that the demo can subscribe to.

2. **Reconnection with exponential backoff**
   - Implement reconnection logic with delays of approximately 1s, 2s, and 3s (cap) after disconnect.
   - Respect offline/browser conditions and explicit disconnects (do not hammer the server).
   - Log each reconnection attempt and outcome via the SDK logging bus.

3. **Surface status and errors in the demo**
   - Implement `apps/demo/components/ConnectionBanner.tsx` (or similar) wired to the connection status stream.
   - Ensure connection errors produce structured `CommandResult` entries with `status: "error"`, `requestId`, and human-readable details.
   - Add user-visible messaging (toast or banner) for persistent connection problems, with a simple retry action.

4. **Integrate with the command pipeline**
   - Wire the connection module so incoming messages are parsed into `CommandPayload` and forwarded to the dispatcher.
   - Ensure unknown/invalid messages are logged as warnings (`UNHANDLED_COMMAND` style) without crashing the app.
   - Verify that when the connection drops, the dispatcher and UI remain stable and simply stop receiving commands until reconnection.

5. **Telemetry and monitoring**
   - Emit connection lifecycle events into the command timeline/logging UI (connected, reconnecting, offline, error).
   - Ensure connection-related logs follow the existing logging strategy (severity levels, capped history) and can flow into optional monitoring (e.g., Sentry) without special cases.

When updating this story, Dev should adjust Tasks/Subtasks and Dev Notes to reflect the actual implementation; leave QA Results to the QA agent.

### Data Models

- Connection-related data is mostly transient state (connection status, retry counts) and can be modeled as small internal TypeScript types or enums.
- No persistent data storage or complex schemas are required for this story.

### API Specifications

- WebSocket messages must be parsed into the shared `CommandPayload` structure defined in the shared types module.  
  [Source: architecture/shared-types-and-api.md#shared-types--api-contract]
- The connection layer should pass through message payloads without mutating semantic fields (command, elementId, payload).

### Component Specifications

- `ConnectionBanner` (or similar) in the demo app should:
  - Display clear textual status (Connecting / Connected / Reconnecting / Offline).
  - Use color and iconography consistent with the UX spec’s status and feedback patterns.  
    [Source: front-end-spec.md#command-feedback-guidelines]
  - Avoid blocking primary interactions; it should be informative, not modal.

### File Locations & Structure

- WebSocket client implementation:
  - `packages/sdk/src/core/connection/*` for connection management and retry logic.  
    [Source: architecture/overview-and-modules.md#module-boundaries]
- Demo UI components:
  - `apps/demo/components/ConnectionBanner.tsx` (or equivalent) for the visual indicator.  
    [Source: architecture/overview-and-modules.md#module-boundaries]
- Logging integration:
  - Use the existing logging/event bus module in `packages/sdk/src/logging` rather than ad-hoc console logs.  
    [Source: architecture/overview-and-modules.md#module-boundaries]

### Testing Requirements

- Unit tests for connection module:
  - Validate status transitions and reconnection timing (1s → 2s → 3s cap).  
    [Source: architecture/platform-deployment.md#resilience--monitoring]
  - Ensure error conditions (e.g., server closes, network errors) emit appropriate events without throwing.
- Integration tests in demo app:
  - Simulate connection loss and verify banner updates and logs.  
    [Source: front-end-spec.md#user-flows]
- Ensure tests can be executed via the monorepo test commands established in Story 1.1.

### Technical Constraints & Considerations

- WebSocket URL should be configurable so the same SDK can connect to local mocks and remote environments.  
  [Source: architecture/platform-deployment.md#deployment-blueprint]
- Reconnection logic must not create tight loops that violate performance targets or flood logs.  
  [Source: architecture/security-performance-monitoring.md#performance-targets]

## Testing

- Manually verify connection lifecycle: initial connect, transient disconnect, reconnection, and offline states.
- Confirm that connection errors always result in visible UI feedback and structured log entries but never crash the demo.

## Change Log

| Date       | Version | Description                                   | Author |
| ---------- | ------- | --------------------------------------------- | ------ |
| 2025-11-14 | 0.1.0   | Initial draft of Story 1.2 and task breakdown | SM     |

## Dev Agent Record

_This section is reserved for the Dev Agent to fill in during implementation (agent model, debug log references, completion notes, and file list)._ 

## QA Results

### QA Validation Playbook

When this story is ready for QA review:

1. **Verify Acceptance Criteria directly**
   - AC1: Confirm the WebSocket client connects to a configurable endpoint and logs status transitions (check logs and ConnectionBanner behavior).
   - AC2: Simulate disconnects and verify exponential backoff reconnection (approx. 1s → 2s → 3s delays) and that it stops or slows appropriately when offline.
   - AC3: Force connection errors (e.g., wrong endpoint, network issues) and confirm they surface in the UI and logs without crashing the SDK or demo.

2. **Check architecture alignment**
   - Ensure the connection code lives under `packages/sdk/src/core/connection` and uses the existing logging infrastructure.
   - Verify that the demo’s status UI matches the intended responsibilities in the architecture and UX docs.

3. **DX & testability**
   - From the monorepo, run the tests covering connection behavior (unit/integration) as defined by the Dev agent.
   - Confirm that connection and reconnection behaviors are inspectable via the command timeline/logs.

4. **Record QA result**
   - Summarize findings here with status (READY / NEEDS REVISION / BLOCKED) and any specific issues or follow-ups.

_This section is reserved for the QA Agent to record validation results and gate decisions for this story._
