# Story 1.3 – Element Targeting Utility

## Status

Approved

## Story

**As a** frontend UI command SDK maintainer,
**I want** a robust element targeting utility with retries and fallbacks,
**so that** remote commands can reliably find and act on the intended DOM elements without breaking the page.

## Acceptance Criteria

From PRD Epic 1 – SDK Foundations & Infrastructure:

1. AC1: `data-elementid` resolution works with retry (five attempts, 100 ms interval).
2. AC2: Custom selector override via payload options finds elements when data attribute is missing.
3. AC3: Failure to locate an element emits structured warnings but allows subsequent commands to proceed.

## Tasks / Subtasks

- [ ] Task 1 – Implement `data-elementid`-based targeting with retry (AC: 1)
  - [ ] Create `packages/sdk/src/targeting` module responsible for resolving DOM elements from `elementId` using `data-elementid` attributes.  
        [Source: architecture/overview-and-modules.md#module-boundaries]
  - [ ] Implement a retry loop of 5 attempts spaced 100 ms apart before concluding that an element cannot be found.  
        [Source: architecture/element-targeting.md#element-targeting-strategy]
  - [ ] Ensure the resolver can be used by all command handlers and the dispatcher without duplicating logic.  
        [Source: architecture/command-pipeline.md#websocket-command-pipeline]

- [ ] Task 2 – Support selector-based override via payload options (AC: 2)
  - [ ] Extend the resolver to accept an optional CSS selector from `payload.options.selector` to handle dynamic or non-annotated elements.  
        [Source: architecture/element-targeting.md#element-targeting-strategy]
  - [ ] Define clear precedence rules (e.g., `data-elementid` first, then selector) and document them in the Dev Notes.  
        [Source: architecture/element-targeting.md#element-targeting-strategy]
  - [ ] Ensure selector-based lookups also participate in the same retry strategy.

- [ ] Task 3 – Emit structured warnings and integrate with logging (AC: 3)
  - [ ] Define a `TargetResolutionWarning` type or message format that includes `elementId`, optional selector, and reason for failure.  
        [Source: architecture/element-targeting.md#element-targeting-strategy]
  - [ ] Ensure the dispatcher emits warnings using the shared `CommandResult` schema with `status: "warning"` and a meaningful `details` message.  
        [Source: architecture/shared-types-and-api.md#shared-types--api-contract]
  - [ ] Integrate warnings into the demo command timeline and any overlay UI that hints at remediation.  
        [Source: architecture/element-targeting.md#element-targeting-strategy]

- [ ] Task 4 – Handle lifecycle and reattachment behavior (AC: 1, 2, 3)
  - [ ] Use `MutationObserver` or equivalent to detect when targeted elements are removed from the DOM and ensure any attached overlays or listeners are cleaned up.  
        [Source: architecture/element-targeting.md#element-targeting-strategy]
  - [ ] Implement reattachment logic for overlays so that when elements reappear, AI buttons or visual markers are restored based on prior configuration.  
        [Source: architecture/element-targeting.md#element-targeting-strategy]
  - [ ] Confirm that element removal does not cause runtime exceptions in command handlers.

- [ ] Task 5 – UX and accessibility considerations for targeting feedback (AC: 3)
  - [ ] Ensure missing-element warnings produce clear, accessible UI feedback (e.g., toast + timeline entry) with guidance on how to fix the targeting configuration.  
        [Source: front-end-spec.md#command-feedback-guidelines]
  - [ ] Avoid flashing or overly aggressive highlight behavior when element resolution repeatedly fails.  
        [Source: architecture/security-performance-monitoring.md#performance-targets]

## Dev Notes

### Previous Story Insights

- Relies on Story 1.1 (monorepo and tooling) and Story 1.2 (connection and dispatcher integration) to provide the context and plumbing for incoming commands.

### Implementation Playbook (Dev Agent)

Follow these steps when implementing this story:

1. **Targeting module foundation**
   - Create `packages/sdk/src/targeting` to centralize element resolution logic.
   - Implement resolution by `data-elementid` with a retry loop of 5 attempts × 100ms before giving up.
   - Ensure all command handlers and the dispatcher depend on this module, not direct DOM queries.

2. **Selector override support**
   - Extend the resolver to optionally use `payload.options.selector` as a fallback when `data-elementid` is missing or insufficient.
   - Define and document precedence rules (e.g., try `data-elementid` first, then selector) within the Dev Notes or code comments.
   - Apply the same retry behavior for selector-based resolution.

3. **Warnings and logging**
   - Define a `TargetResolutionWarning` structure including `elementId`, optional selector, and a clear reason.
   - Ensure the dispatcher emits `CommandResult` entries with `status: "warning"` when targets cannot be resolved, and that these appear in the command timeline.

4. **Lifecycle and reattachment**
   - Use `MutationObserver` (or equivalent) to detect when targeted elements are removed and clean up overlays/listeners.
   - Implement reattachment so that when elements reappear, any associated overlays (e.g., AI buttons) are restored from prior configuration.
   - Confirm that element removal or reattachment never throws unhandled errors in handlers.

5. **UX and accessibility feedback**
   - Make sure missing-element scenarios produce clear, accessible feedback (timeline entries and/or toasts) with guidance for fixing selectors.
   - Avoid noisy visual behavior (flashing, excessive retries) that could violate performance or UX guidelines.

Dev should keep Tasks/Subtasks and Dev Notes in sync with the actual implementation; QA Results are reserved for the QA agent.

### Data Models

- Target resolution results can be represented as a small internal type, e.g., `{ element: HTMLElement | null; warnings: TargetResolutionWarning[] }`.
- These details are not persisted and are only used within the lifetime of each command execution.  
  [Source: architecture/command-pipeline.md#websocket-command-pipeline]

### API Specifications

- Resolver input should match `CommandPayload` fields: `elementId` and optional `payload.options.selector`.  
  [Source: architecture/shared-types-and-api.md#shared-types--api-contract]
- Warnings emitted from failures should map into the shared `CommandResult` shape with `status: "warning"`.

### Component Specifications

- Demo UI should visually indicate when targeting fails through the existing command timeline and any overlay assistive UI.
- No new standalone visual components are strictly required for this story, but the behavior should align with the UX spec’s feedback and accessibility goals.  
  [Source: front-end-spec.md#command-feedback-guidelines]

### File Locations & Structure

- Core targeting utilities:
  - `packages/sdk/src/targeting/*` for resolver and related logic.  
    [Source: architecture/overview-and-modules.md#module-boundaries]
- Integration with dispatcher:
  - `packages/sdk/src/core/dispatcher` should depend on the targeting module instead of direct DOM queries.  
    [Source: architecture/command-pipeline.md#websocket-command-pipeline]

### Testing Requirements

- Unit tests:
  - Verify that existing elements are found immediately and within the retry window.
  - Verify that absent elements trigger correct retry counts and warnings.
  - Validate precedence rules between `data-elementid` and selector-based targeting.
- Integration tests:
  - Ensure overlay reattachment behavior works in cases where elements are temporarily removed (e.g., conditional rendering).  
    [Source: architecture/element-targeting.md#element-targeting-strategy]

### Technical Constraints & Considerations

- Targeting logic must avoid expensive DOM scans on every command to maintain performance targets.  
  [Source: architecture/security-performance-monitoring.md#performance-targets]
- All failures should degrade gracefully without throwing unhandled exceptions or blocking subsequent commands.

## Testing

- Manually verify element targeting using demo components with `data-elementid` attributes and with selector overrides.
- Confirm that missing or incorrect identifiers result in warnings but do not break the WebSocket connection or crash the page.

## Change Log

| Date       | Version | Description                                   | Author |
| ---------- | ------- | --------------------------------------------- | ------ |
| 2025-11-14 | 0.1.0   | Initial draft of Story 1.3 and task breakdown | SM     |

## Dev Agent Record

_This section is reserved for the Dev Agent to fill in during implementation (agent model, debug log references, completion notes, and file list)._ 

## QA Results

### QA Validation Playbook

When this story is ready for QA review:

1. **Verify Acceptance Criteria directly**
   - AC1: Confirm that elements with `data-elementid` are resolved reliably, including cases where they appear slightly after command receipt (retry behavior).
   - AC2: Test selector overrides via `payload.options.selector` and verify they work when `data-elementid` is absent.
   - AC3: Force unresolved targets and confirm structured warnings appear in logs/timeline and subsequent commands still run.

2. **Check architecture alignment**
   - Verify that the targeting logic resides in `packages/sdk/src/targeting` and that the dispatcher depends on it.
   - Confirm integration with overlays and lifecycle handling matches the architecture docs.

3. **UX & accessibility checks**
   - Ensure missing-target warnings are understandable, accessible, and not visually disruptive.

4. **Record QA result**
   - Summarize findings here with status (READY / NEEDS REVISION / BLOCKED) and concrete gaps.

_This section is reserved for the QA Agent to record validation results and gate decisions for this story._
