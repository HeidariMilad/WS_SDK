# Story 4.2 – Mock Services Setup

## Status

Approved

## Story

**As a** developer or evaluator,
**I want** mock WebSocket and REST services that exercise all commands,
**so that** I can run the demo end-to-end locally and in CI without relying on real backends.

## Acceptance Criteria

From PRD Epic 4 – Demo Application & Documentation:

1. AC1: `apps/mocks` exports start scripts launching WebSocket and REST endpoints.
2. AC2: Command fixture playlist exercises every command automatically.
3. AC3: README documents how to run mocks alongside Next.js dev server.

## Tasks / Subtasks

- [ ] Task 1 – Implement WebSocket mock server (AC: 1, 2)
  - [ ] Create `apps/mocks/ws/server.ts` to serve WebSocket connections and dispatch scripted command playlists.  
        [Source: architecture/overview-and-modules.md#module-boundaries]
  - [ ] Provide a configuration mechanism for selecting different playlists (e.g., basic, full, stress).

- [ ] Task 2 – Implement mock AI prompt API (AC: 1, 2)
  - [ ] Implement `/mock/ai_generate_ui_prompt` API endpoint in `apps/mocks/api` using the shared `AiPromptRequest` and `AiPromptResponse` types.  
        [Source: architecture/shared-types-and-api.md#shared-types--api-contract]
  - [ ] Return deterministic prompts and metadata suitable for demo and tests.

- [ ] Task 3 – Command fixture playlists (AC: 2)
  - [ ] Define fixture files in `apps/mocks/fixtures` that cover all 11 command types.  
        [Source: architecture/architecture-next-steps.md#next-steps]
  - [ ] Include scenarios for success, warnings (e.g., missing elements), and error cases.

- [ ] Task 4 – Scripts and documentation (AC: 1, 3)
  - [ ] Add npm scripts in `apps/mocks/package.json` to start WebSocket and REST mocks.  
        [Source: architecture/project-structure.md#project-structure--workflow]
  - [ ] Update root README and/or dedicated docs with instructions for running mocks with the demo.

- [ ] Task 5 – CI integration (AC: 1, 2, 3)
  - [ ] Ensure CI workflow spins up mocks when running integration/e2e tests.  
        [Source: architecture/platform-deployment.md#deployment-blueprint]
  - [ ] Verify tests pass reliably on CI using the same playlists as local runs.

## Dev Notes

### Previous Story Insights

- Relies on shared types, command definitions, and AI prompt workflow from earlier stories.
- This story provides the backing services used by the demo and tests.

### Implementation Playbook (Dev Agent)

Follow these steps when implementing this story:

1. **WebSocket mock server**
   - Implement `apps/mocks/ws/server.ts` to serve WebSocket connections and scripted command playlists.
   - Provide a way to choose different playlists (e.g., basic vs full coverage).

2. **Mock AI prompt API**
   - Implement `/mock/ai_generate_ui_prompt` in `apps/mocks/api` using shared `AiPromptRequest`/`AiPromptResponse` types.
   - Return deterministic responses for predictable demos/tests.

3. **Command fixture playlists**
   - Create fixture files under `apps/mocks/fixtures` that cover all 11 commands, including success, warning, and error cases.

4. **Scripts & docs**
   - Add npm scripts in `apps/mocks/package.json` to start WS and REST mocks.
   - Update README/docs with instructions for running mocks alongside the demo.

5. **CI integration**
   - Ensure CI can spin up mocks for integration/e2e tests and that tests pass reliably using the playlists.

Dev should keep Tasks/Subtasks and Dev Notes current; QA Results are for QA.

### Data Models

- Mocks should use shared types for commands and prompt requests/responses to maintain type safety and contract consistency.

### API Specifications

- WebSocket server must send messages in the `CommandPayload` format.
- REST mock must follow the OpenAPI contract for `/mock/ai_generate_ui_prompt`.

### Component Specifications

- No new UI components; focus is on backend mocks.

### File Locations & Structure

- `apps/mocks/ws`, `apps/mocks/api`, and `apps/mocks/fixtures` as described in architecture docs.

### Testing Requirements

- Integration tests verifying that the demo can connect to mocks and receive commands.
- Optional contract tests ensuring mock responses match shared types.

### Technical Constraints & Considerations

- Keep mocks simple and deterministic; avoid external dependencies or complex state.

## Testing

- Run demo and mocks together; verify command playback, AI prompt flows, and logging all function as expected.

## Change Log

| Date       | Version | Description                                   | Author |
| ---------- | ------- | --------------------------------------------- | ------ |
| 2025-11-14 | 0.1.0   | Initial draft of Story 4.2 and task breakdown | SM     |

## Dev Agent Record

_This section is reserved for the Dev Agent to fill in during implementation (agent model, debug log references, completion notes, and file list)._ 

## QA Results

### QA Validation Playbook

When this story is ready for QA review:

1. **Verify Acceptance Criteria directly**
   - AC1: Confirm `apps/mocks` can start WS and REST endpoints via documented scripts.
   - AC2: Run the playlists and confirm all commands are exercised automatically.
   - AC3: Ensure README/docs correctly describe how to run mocks with the demo.

2. **Integration & reliability**
   - Verify the demo connects to mocks in both local and CI scenarios, and tests pass consistently.

3. **Record QA result**
   - Summarize findings with status (READY / NEEDS REVISION / BLOCKED) and any issues.

_This section is reserved for the QA Agent to record validation results and gate decisions for this story._
