# Story 3.1 – AI Button Factory

## Status

Approved

## Story

**As a** developer integrating the SDK,
**I want** a simple AI button factory API to attach configurable AI-assist buttons to UI elements,
**so that** I can easily enable AI-driven assistance in the demo and host applications.

## Acceptance Criteria

From PRD Epic 3 – AI Assist Button & Chatbot Integration:

1. AC1: Public API attaches buttons with configurable style and placement.
2. AC2: Buttons remove themselves cleanly if elements unmount or injection is refreshed.
3. AC3: Styling respects host CSS and avoids layout shifts.

## Tasks / Subtasks

- [ ] Task 1 – Design AI button factory API surface (AC: 1)
  - [ ] Define a public API (e.g., `attachAiButton(elementId, options)`) in the SDK’s `ai-overlay` module.  
        [Source: architecture/overview-and-modules.md#module-boundaries]
  - [ ] Support options for style, icon, placement (`top-left`, `top-right`, `center`, or custom), and labeling.  
        [Source: architecture/ai-overlay.md#ai-assist-button-rendering]
  - [ ] Document the API in the SDK README for later Story 4.3.

- [ ] Task 2 – Implement overlay registry and rendering (AC: 1, 2)
  - [ ] Use a `WeakMap`-backed overlay registry to prevent duplicate attachments and to track overlay configuration per host element.  
        [Source: architecture/ai-overlay.md#ai-assist-button-rendering]
  - [ ] Render AI buttons into a shared `.sdk-overlay-root` portal attached to `document.body` with stable z-index and layout behavior.  
        [Source: architecture/ai-overlay.md#ai-assist-button-rendering]

- [ ] Task 3 – Handle unmount, reattachment, and cleanup (AC: 2)
  - [ ] Use `MutationObserver` integration from targeting/overlay modules to detect when host elements unmount and remove attached AI buttons.  
        [Source: architecture/element-targeting.md#element-targeting-strategy]
  - [ ] When elements reappear, replay overlay configuration from the registry to reattach buttons.  
        [Source: architecture/ai-overlay.md#ai-assist-button-rendering]

- [ ] Task 4 – Placement, styling, and layout safety (AC: 1, 3)
  - [ ] Implement position options including collision detection to avoid clipping and viewport overflow.  
        [Source: architecture/ai-overlay.md#ai-assist-button-rendering]
  - [ ] Ensure AI buttons adjust to host layout without causing layout shifts; use absolute positioning and minimal DOM impact.  
        [Source: front-end-spec.md#branding--style-guide]
  - [ ] Respect host CSS and theme; allow custom className or style overrides.

- [ ] Task 5 – Accessibility and UX behavior (AC: 1, 3)
  - [ ] Provide accessible `aria-label` and keyboard focus behavior consistent with UX spec.  
        [Source: front-end-spec.md#accessibility-requirements]
  - [ ] Respect `prefers-reduced-motion` for any hover or attention-grabbing animations.  
        [Source: architecture/ai-overlay.md#ai-assist-button-rendering]

## Dev Notes

### Previous Story Insights

- Relies on targeting and overlay infrastructure from Epics 1–2.
- This story introduces the first visible AI-specific UI component.

### Implementation Playbook (Dev Agent)

Follow these steps when implementing this story:

1. **Factory API design**
   - Define a public API (e.g., `attachAiButton(elementId, options)`) in the SDK’s `ai-overlay` module.
   - Support options for style, icon, placement, and label, with reasonable defaults.

2. **Overlay registry & rendering**
   - Implement a `WeakMap`-backed registry to avoid duplicate overlays and store config per host element.
   - Render AI buttons via a shared `.sdk-overlay-root` portal attached to `document.body` with stable z-index and minimal layout impact.

3. **Unmount, reattachment, and cleanup**
   - Use existing targeting/lifecycle hooks (e.g., `MutationObserver`) to remove overlays when hosts unmount.
   - Reattach overlays when elements reappear using saved config from the registry.

4. **Placement, styling, and safety**
   - Implement placement options with basic collision detection to avoid clipping/overflow.
   - Ensure overlays adapt to host layout and do not cause layout shifts; allow host overrides via className/styles.

5. **Accessibility & UX**
   - Ensure AI buttons meet accessibility requirements (aria-labels, focus outlines, hit area) and respect reduced-motion preferences.

Dev should adjust Tasks/Subtasks and Dev Notes to match actual implementation, leaving QA Results to QA.

### Data Models

- Overlay configuration objects should be small and serializable (placement, style, metadata) but are not persisted beyond runtime.

### API Specifications

- Factory API must be ergonomic and well-typed in TypeScript.
- Interface should align with how future stories (prompt workflow and chatbot bridge) will use it.

### Component Specifications

- `AIOverlayButton` component should follow the style, size, and state guidelines from the UX spec.  
  [Source: front-end-spec.md#component-library]
- Ensure hit target size and focus outlines meet accessibility expectations.

### File Locations & Structure

- Overlay module: `packages/sdk/src/ai-overlay/*`.
- Demo components using the factory: within `apps/demo` (e.g., overlay configuration panel, element inspector).

### Testing Requirements

- Unit tests for overlay registry behavior (deduplication, cleanup).
- Integration tests in demo verifying that attaching/detaching AI buttons works across route changes and dynamic content.

### Technical Constraints & Considerations

- Avoid memory leaks by ensuring overlays are garbage-collected when host elements and registry entries are no longer needed.
- Maintain performance and keep overlays lightweight.

## Testing

- Manually attach AI buttons to various elements in the demo; verify placement, style, and cleanup on unmount.

## Change Log

| Date       | Version | Description                                   | Author |
| ---------- | ------- | --------------------------------------------- | ------ |
| 2025-11-14 | 0.1.0   | Initial draft of Story 3.1 and task breakdown | SM     |

## Dev Agent Record

_This section is reserved for the Dev Agent to fill in during implementation (agent model, debug log references, completion notes, and file list)._ 

## QA Results

### QA Validation Playbook

When this story is ready for QA review:

1. **Verify Acceptance Criteria directly**
   - AC1: Confirm that the public API attaches AI buttons with configurable style and placement.
   - AC2: Verify buttons are removed cleanly when host elements unmount and reattached as expected.
   - AC3: Ensure styling respects host CSS and does not cause layout shifts.

2. **UX and accessibility**
   - Check that buttons meet accessibility requirements and behave as per the UX spec.

3. **Record QA result**
   - Summarize findings here with status (READY / NEEDS REVISION / BLOCKED) and any issues.

_This section is reserved for the QA Agent to record validation results and gate decisions for this story._
