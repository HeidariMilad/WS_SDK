# Story 4.1 – Showcase Page & Visual Logger

## Status

Approved

## Story

**As a** technical evaluator,
**I want** a single showcase page with a visual command logger,
**so that** I can observe all command effects and logs in one place without digging through code or devtools.

## Acceptance Criteria

From PRD Epic 4 – Demo Application & Documentation:

1. AC1: Page includes buttons, inputs, textarea, dropdowns, modal, and chatbot components.
2. AC2: Visual log/console panel displays incoming commands, statuses, and errors.
3. AC3: Demo includes inline guidance or links to command triggers.

## Tasks / Subtasks

- [ ] Task 1 – Build the main demo layout (AC: 1)
  - [ ] Implement a main demo page in `apps/demo` that includes the Status & Controls Bar, Interactive Canvas, Chatbot Drawer, and Command Event Stream sections.  
        [Source: front-end-spec.md#information-architecture]
  - [ ] Place buttons, form fields, dropdowns, modal triggers, and chatbot entry points in the Interactive Canvas.

- [ ] Task 2 – Implement the visual command logger (AC: 2)
  - [ ] Build a `CommandTimeline` or `CommandLog` component showing command name, elementId, status, timestamp, and short details.  
        [Source: front-end-spec.md#command-feedback-guidelines]
  - [ ] Integrate with the SDK logging bus to stream events in real time.
  - [ ] Support filtering or collapsing entries for readability.

- [ ] Task 3 – Inline guidance and documentation hooks (AC: 3)
  - [ ] Add inline text or tooltips explaining how commands are triggered in the demo (e.g., “These buttons are controlled by remote commands”).
  - [ ] Link to PRD, architecture, or README sections relevant to evaluators from within the demo (optional but encouraged).

- [ ] Task 4 – Accessibility and responsiveness (AC: 1, 2, 3)
  - [ ] Ensure the page layout responds well to different viewport sizes (stacking sections on mobile, etc.).  
        [Source: front-end-spec.md#responsiveness-strategy]
  - [ ] Verify keyboard navigation and ARIA attributes on control and log components.

## Dev Notes

### Previous Story Insights

- Builds on all previous infrastructure, command handlers, AI overlay, and chatbot integration.
- This story brings everything together into a coherent evaluator-facing UI.

### Implementation Playbook (Dev Agent)

Follow these steps when implementing this story:

1. **Main layout**
   - Implement the main demo page with Status & Controls Bar, Interactive Canvas, Chatbot Drawer, and Command Event Stream sections.
   - Place buttons, inputs, textarea, dropdowns, modal triggers, and chatbot entry points clearly in the canvas.

2. **Visual command logger**
   - Build a `CommandTimeline`/`CommandLog` component that subscribes to the SDK logging bus.
   - Show command name, elementId, status, timestamp, and key details.
   - Support basic filtering/collapsing for readability.

3. **Inline guidance**
   - Add text/tooltips explaining how commands are triggered and what sections represent.
   - Optionally link to PRD/architecture/README from within the UI.

4. **Accessibility & responsiveness**
   - Ensure layout behaves well across viewports (e.g., stacking on smaller screens).
   - Verify keyboard navigation and ARIA attributes for controls and log entries.

Dev should keep Tasks/Subtasks and Dev Notes updated; QA Results are for QA.

### Data Models

- Command log items should map directly to `CommandResult` events and any additional metadata from the SDK logging bus.

### API Specifications

- Log components subscribe to SDK logging interfaces rather than direct WebSocket or handler internals.

### Component Specifications

- Follow the UX spec’s layout, color, and typography guidelines for the main demo shell and log components.  
  [Source: front-end-spec.md#branding--style-guide]
- Ensure each log entry is screen-reader friendly and keyboard accessible.

### File Locations & Structure

- Main page: `apps/demo/app/page.tsx` (or similar).  
  [Source: architecture/project-structure.md#project-structure--workflow]
- Log components: `apps/demo/components/CommandTimeline.tsx`.

### Testing Requirements

- Manual and automated tests verifying that all required components are present on the main page.
- Snapshot or UI tests for log rendering behavior could be added but are optional.

### Technical Constraints & Considerations

- Avoid performance degradation when many log entries are rendered; consider virtualization or entry capping if needed.

## Testing

- Use mock playlists to exercise all command types and verify they appear in the log and drive visible effects on the page.

## Change Log

| Date       | Version | Description                                   | Author |
| ---------- | ------- | --------------------------------------------- | ------ |
| 2025-11-14 | 0.1.0   | Initial draft of Story 4.1 and task breakdown | SM     |

## Dev Agent Record

_This section is reserved for the Dev Agent to fill in during implementation (agent model, debug log references, completion notes, and file list)._ 

## QA Results

### QA Validation Playbook

When this story is ready for QA review:

1. **Verify Acceptance Criteria directly**
   - AC1: Confirm the page includes buttons, inputs, textarea, dropdowns, modal, and chatbot components.
   - AC2: Ensure the visual log panel displays incoming commands with statuses and errors.
   - AC3: Confirm inline guidance or links exist to help evaluators understand command triggers.

2. **Accessibility & responsiveness**
   - Test keyboard navigation, ARIA attributes, and responsive behavior.

3. **Record QA result**
   - Summarize findings with status (READY / NEEDS REVISION / BLOCKED) and key observations.

_This section is reserved for the QA Agent to record validation results and gate decisions for this story._
