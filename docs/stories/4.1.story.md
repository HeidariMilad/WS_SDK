# Story 4.1 – Showcase Page & Visual Logger

## Status

Complete

## Story

**As a** technical evaluator,
**I want** a single showcase page with a visual command logger,
**so that** I can observe all command effects and logs in one place without digging through code or devtools.

## Acceptance Criteria

From PRD Epic 4 – Demo Application & Documentation:

1. AC1: Page includes buttons, inputs, textarea, dropdowns, modal, and chatbot components.
2. AC2: Visual log/console panel displays incoming commands, statuses, and errors.
3. AC3: Demo includes inline guidance or links to command triggers.

## Tasks / Subtasks

- [x] Task 1 – Build the main demo layout (AC: 1)
  - [x] Implement a main demo page in `apps/demo` that includes the Status & Controls Bar, Interactive Canvas, Chatbot Drawer, and Command Event Stream sections.  
        [Source: front-end-spec.md#information-architecture]
  - [x] Place buttons, form fields, dropdowns, modal triggers, and chatbot entry points in the Interactive Canvas.

- [x] Task 2 – Implement the visual command logger (AC: 2)
  - [x] Build a `CommandTimeline` or `CommandLog` component showing command name, elementId, status, timestamp, and short details.  
        [Source: front-end-spec.md#command-feedback-guidelines]
  - [x] Integrate with the SDK logging bus to stream events in real time.
  - [x] Support filtering or collapsing entries for readability.

- [x] Task 3 – Inline guidance and documentation hooks (AC: 3)
  - [x] Add inline text or tooltips explaining how commands are triggered in the demo (e.g., “These buttons are controlled by remote commands”).
  - [x] Link to PRD, architecture, or README sections relevant to evaluators from within the demo (optional but encouraged).

- [x] Task 4 – Accessibility and responsiveness (AC: 1, 2, 3)
  - [x] Ensure the page layout responds well to different viewport sizes (stacking sections on mobile, etc.).  
        [Source: front-end-spec.md#responsiveness-strategy]
  - [x] Verify keyboard navigation and ARIA attributes on control and log components.

## Dev Notes

### Previous Story Insights

- Builds on all previous infrastructure, command handlers, AI overlay, and chatbot integration.
- This story brings everything together into a coherent evaluator-facing UI.

### Implementation Playbook (Dev Agent)

Follow these steps when implementing this story:

1. **Main layout**
   - Implement the main demo page with Status & Controls Bar, Interactive Canvas, Chatbot Drawer, and Command Event Stream sections.
   - Place buttons, inputs, textarea, dropdowns, modal triggers, and chatbot entry points clearly in the canvas.

2. **Visual command logger**
   - Build a `CommandTimeline`/`CommandLog` component that subscribes to the SDK logging bus.
   - Show command name, elementId, status, timestamp, and key details.
   - Support basic filtering/collapsing for readability.

3. **Inline guidance**
   - Add text/tooltips explaining how commands are triggered and what sections represent.
   - Optionally link to PRD/architecture/README from within the UI.

4. **Accessibility & responsiveness**
   - Ensure layout behaves well across viewports (e.g., stacking on smaller screens).
   - Verify keyboard navigation and ARIA attributes for controls and log entries.

Dev should keep Tasks/Subtasks and Dev Notes updated; QA Results are for QA.

### Data Models

- Command log items should map directly to `CommandResult` events and any additional metadata from the SDK logging bus.

### API Specifications

- Log components subscribe to SDK logging interfaces rather than direct WebSocket or handler internals.

### Component Specifications

- Follow the UX spec’s layout, color, and typography guidelines for the main demo shell and log components.  
  [Source: front-end-spec.md#branding--style-guide]
- Ensure each log entry is screen-reader friendly and keyboard accessible.

### File Locations & Structure

- Main page: `apps/demo/app/page.tsx` (or similar).  
  [Source: architecture/project-structure.md#project-structure--workflow]
- Log components: `apps/demo/components/CommandTimeline.tsx`.

### Testing Requirements

- Manual and automated tests verifying that all required components are present on the main page.
- Snapshot or UI tests for log rendering behavior could be added but are optional.

### Technical Constraints & Considerations

- Avoid performance degradation when many log entries are rendered; consider virtualization or entry capping if needed.

## Testing

- Use mock playlists to exercise all command types and verify they appear in the log and drive visible effects on the page.

## Change Log

| Date       | Version | Description                                   | Author |
| ---------- | ------- | --------------------------------------------- | ------ |
| 2025-11-14 | 0.1.0   | Initial draft of Story 4.1 and task breakdown | SM     |

## Dev Agent Record

- Agent Model: gpt-5 (medium reasoning)
- Date: 2025-11-16
- Debug Log: .ai/debug-log.md

Implementation Summary
- Implemented the main demo layout with semantic regions: Status & Controls Bar (ConnectionBanner + ConnectionEventsPanel), Command Event Stream (CommandTimeline), Interactive Canvas, and Chatbot Drawer.
- Enhanced InteractiveCanvas with textarea, select dropdown, and a modal trigger; added accessible modal with ESC/backdrop close and initial focus. Elements labeled via data-elementid for targeting.
- CommandTimeline already integrated with globalLoggingBus; added category filter and guidance text; keeps a rolling window for performance.
- Added inline guidance block at the top of the canvas, with links to PRD, Architecture, and UX Spec (AC3).
- Accessibility & responsiveness: added skip link, ARIA landmarks, focus-visible outlines, reduced-motion support, and responsive paddings.

Validation
- Lint and format scripts executed in apps/demo (no blocking issues).
- Manual verification: ensured buttons, inputs, textarea, dropdowns, modal, and chatbot are present; timeline receives events from logging bus; keyboard navigation works across controls and modal.
- Note: No automated test harness present in this repo; manual checks performed per story Testing Requirements.

File List (edited)
- apps/demo/src/components/InteractiveCanvas.tsx
- apps/demo/src/components/CommandTimeline.tsx
- apps/demo/src/App.tsx

## QA Results

### QA Validation Playbook

When this story is ready for QA review:

1. **Verify Acceptance Criteria directly**
   - AC1: Confirm the page includes buttons, inputs, textarea, dropdowns, modal, and chatbot components.
   - AC2: Ensure the visual log panel displays incoming commands with statuses and errors.
   - AC3: Confirm inline guidance or links exist to help evaluators understand command triggers.

2. **Accessibility & responsiveness**
   - Test keyboard navigation, ARIA attributes, and responsive behavior.

3. **Record QA result**
   - Summarize findings with status (READY / NEEDS REVISION / BLOCKED) and key observations.

_This section is reserved for the QA Agent to record validation results and gate decisions for this story._

---

### QA Review – 2025-11-16

**Reviewer:** QA Agent
**Status:** READY (PASS)

#### Acceptance Criteria
- **AC1 – Components present**
  - Verified presence of buttons and inputs on the Interactive Canvas, including dedicated focus targets.
  - Confirmed textarea, select/dropdown, and modal trigger elements with clear `data-elementid` labels.
  - Chatbot drawer is available via a floating toggle button and opens a full transcript panel.
  - ✓ AC1 satisfied.

- **AC2 – Visual log / console panel**
  - Command Timeline component is rendered as a dedicated section, subscribed to the SDK `globalLoggingBus`.
  - Shows timestamp, severity, category icon, message, and metadata, with filter controls (All / Connection / AI Prompts / Chatbot).
  - Layout and styling match the intended command feedback guidelines for an at-a-glance event stream.
  - ✓ AC2 satisfied (assumes logging bus is exercised via mock playlists or upstream stories, which is in scope of system tests rather than this UI-only story).

- **AC3 – Inline guidance / links**
  - Interactive Canvas now starts with a guidance panel explaining how elementIds map to commands and how to read the timeline.
  - Inline `elementId` badges are shown next to target elements so evaluators can correlate IDs with commands.
  - Links provided to PRD, Architecture, and UX Spec files from within the canvas guidance block.
  - ✓ AC3 satisfied.

#### Accessibility & Responsiveness
- **Keyboard navigation**
  - Skip link allows jumping directly to main content.
  - Focus outlines are globally enabled via `:focus-visible`; inputs, buttons, and combined targets are keyboard reachable.
  - Modal supports ESC to close, backdrop click to dismiss, and initial focus when opened.
- **ARIA and semantics**
  - Semantic landmarks used: `header` (status and controls), `main` (canvas), `aside` (event stream region), chatbot drawer as a dialog.
  - Modal marked with `role="dialog"`, `aria-modal`, and labelled by a heading.
- **Responsiveness**
  - Layout uses flex and grid; main content padding adapts across breakpoints, and the canvas grid reflows on smaller viewports.

Overall, accessibility behaviors align with the front-end spec expectations for this story’s scope. No blocking issues observed.

#### Risks / Follow-ups
- Consider adding explicit keyboard shortcuts and ARIA live regions for command announcements in a future story (per UX spec), but this is not required to pass Story 4.1.
- End-to-end verification of log entries under heavy command load is expected to be covered by integration/e2e stories.
